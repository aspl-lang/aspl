import math.geometry

[public]
class Window{

	property any handle = implement("graphics.window.new")
	property string _title
	[public]
	property string title{
		get{
			return _title
		}
		set{
			_title = value
			implement("graphics.window.set_title", handle, value)
		}
	}
	[readpublic]
	property int width
	[readpublic]
	property int height

	[public]
	property int fps{
		get{
			return int(implement("graphics.window.get_fps", handle))
		}
	}

	[readpublic]
	property list<TouchPointer> activeTouchPointers

	[public]
	property callback onLoad = callback(){}
	[public]
	property callback<Canvas> onPaint = callback(Canvas canvas){} // `canvas` is currently guaranteed to be a `RegularCanvas` but this might change in the future (when we implement GPU acceleration)
	[public]
	property callback<int, int> onResize = callback(int width, int height){}
	[public]
	property callback<KeyCode> onKeyPress = callback(KeyCode key){}
	[public]
	property callback<KeyCode> onKeyDown = callback(KeyCode key){}
	[public]
	property callback<KeyCode> onKeyUp = callback(KeyCode key){}
	[public]
	property callback<Point, MouseButton> onMouseClick = callback(Point position, MouseButton button){}
	[public]
	property callback<Point, MouseButton> onMouseDown = callback(Point position, MouseButton button){}
	[public]
	property callback<Point, MouseButton> onMouseUp = callback(Point position, MouseButton button){}
	[public]
	property callback<Point, float, float> onMouseMove = callback(Point end, float deltaX, float deltaY){}
	[public]
	property callback<Point, float, float> onMouseWheel = callback(Point position, float deltaX, float deltaY){}
	[public]
	property callback<TouchPointer> onTouchDown = callback(TouchPointer pointer){}
	[public]
	property callback<TouchPointer, float, float> onTouchMove = callback(TouchPointer pointer, float deltaX, float deltaY){}
	[public]
	property callback<TouchPointer> onTouchUp = callback(TouchPointer pointer){}
	[public]
	property callback<TouchPointer> onTouchCancel = callback(TouchPointer pointer){}

	[public]
	method construct(string|int title, int width, int? height = null){
		if(height == null){
			// legacy support...
			height = width
			width = int(title)
			title = ""
		}
		implement("graphics.window.set_on_load", handle, callback(){
			onLoad.()
		})
		this.title = title
		this.width = width
		this.height = height
		implement("graphics.window.set_size", handle, width, height)
		implement("graphics.window.set_on_resize", handle, callback(int newWidth, int newHeight){
			onResize.(newWidth, newHeight)
			this.width = newWidth
			this.height = newHeight
		})
		implement("graphics.window.set_on_paint", handle, callback(any handle){
			var canvas = new RegularCanvas(int(implement("graphics.canvas.regular.get_width", handle)), int(implement("graphics.canvas.regular.get_height", handle)), handle)
			// TODO: The below two lines are needed since the window doesn't update its size correctly sometimes
			this.width = canvas.width
			this.height = canvas.height
			onPaint.(canvas)
		})
		implement("graphics.window.set_on_key_press", handle, callback(int key){
			onKeyPress.(KeyCode(key))
		})
		implement("graphics.window.set_on_key_down", handle, callback(int key){
			onKeyDown.(KeyCode(key))
		})
		implement("graphics.window.set_on_key_up", handle, callback(int key){
			onKeyUp.(KeyCode(key))
		})
		implement("graphics.window.set_on_mouse_click", handle, callback(float x, float y, int button){
			onMouseClick.(new Point(x, y), MouseButton(button))
		})
		implement("graphics.window.set_on_mouse_down", handle, callback(float x, float y, int button){
			onMouseDown.(new Point(x, y), MouseButton(button))
		})
		implement("graphics.window.set_on_mouse_up", handle, callback(float x, float y, int button){
			onMouseUp.(new Point(x, y), MouseButton(button))
		})
		implement("graphics.window.set_on_mouse_move", handle, callback(float endX, float endY, float deltaX, float deltaY){
			onMouseMove.(new Point(endX, endY), deltaX, deltaY)
		})
		implement("graphics.window.set_on_mouse_wheel", handle, callback(float x, float y, float deltaX, float deltaY){
			onMouseWheel.(new Point(x, y), deltaX, deltaY)
		})
		implement("graphics.window.set_on_touch_down", handle, callback(list<long|float|int> pointerData){
			var pointer = new TouchPointer(long(pointerData[0]), new Point(float(pointerData[1]), float(pointerData[2])), TouchToolType(int(pointerData[3])), float(pointerData[4]))
			var index = -1
			var i = 0
			foreach(activeTouchPointers as activePointer){
				if(activePointer.identifier == pointer.identifier){
					index = i
					break
				}
				i++
			}
			if(index > -1){
				activeTouchPointers[index] = pointer // (erroneously) missed a touch up previously
			}else{
				activeTouchPointers.add(pointer)
			}
			onTouchDown.(pointer)
		})
		implement("graphics.window.set_on_touch_move", handle, callback(list<long|float|int> pointerData){
			var pointer = new TouchPointer(long(pointerData[0]), new Point(float(pointerData[1]), float(pointerData[2])), TouchToolType(int(pointerData[3])), float(pointerData[4]))
			var index = -1
			var i = 0
			foreach(activeTouchPointers as activePointer){
				if(activePointer.identifier == pointer.identifier){
					index = i
					break
				}
				i++
			}
			if(index > -1){ // ignore (erroneously) untracked pointers
				var deltaX = pointer.position.x - activeTouchPointers[index].position.x
				var deltaY = pointer.position.y - activeTouchPointers[index].position.y
				activeTouchPointers[index] = pointer
				onTouchMove.(pointer, deltaX, deltaY)
			}
		})
		implement("graphics.window.set_on_touch_up", handle, callback(list<long|float|int> pointerData){
			var pointer = new TouchPointer(long(pointerData[0]), new Point(float(pointerData[1]), float(pointerData[2])), TouchToolType(int(pointerData[3])), float(pointerData[4]))
			var index = -1
			var i = 0
			foreach(activeTouchPointers as activePointer){
				if(activePointer.identifier == pointer.identifier){
					index = i
					break
				}
				i++
			}
			if(index > -1){
				activeTouchPointers.removeAt(0)
			}
			onTouchUp.(pointer)
		})
		implement("graphics.window.set_on_touch_cancel", handle, callback(list<long|float|int> pointerData){
			var pointer = new TouchPointer(long(pointerData[0]), new Point(float(pointerData[1]), float(pointerData[2])), TouchToolType(int(pointerData[3])), float(pointerData[4]))
			var index = -1
			var i = 0
			foreach(activeTouchPointers as activePointer){
				if(activePointer.identifier == pointer.identifier){
					index = i
					break
				}
				i++
			}
			if(index > -1){
				activeTouchPointers.removeAt(0)
			}
			onTouchCancel.(pointer)
		})
	}

	[public]
	method show(){
		implement("graphics.window.show", handle)
	}

	// isRetainMode returns if this window is in "canvas retain mode", i.e. it preserves drawings between frames
	[public]
	method isRetainMode() returns bool{
		return bool(implement("graphics.window.get_canvas_retain_mode", handle))
	}

	// setRetainMode enables/disables "canvas retain mode" for this window, i.e. preservation of drawings between frames
	[public]
	method setRetainMode(bool value = true){
		implement("graphics.window.set_canvas_retain_mode", handle, value)
	}

	[public]
	method isFullscreen() returns bool{
		return bool(implement("graphics.window.is_fullscreen"))
	}

	[public]
	method toggleFullscreen(){
		implement("graphics.window.toggle_fullscreen", handle)
	}

    [public]
    method isMouseButtonDown(MouseButton button) returns bool{
        return bool(implement("graphics.window.is_mouse_button_down", handle, int(button)))
    }

	[public]
	method isKeyDown(KeyCode key) returns bool{
        return bool(implement("graphics.window.is_key_down", handle, int(key)))
	}

}