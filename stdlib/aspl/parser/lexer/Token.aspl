import aspl.parser.utils

[public]
class Token{

	[static]
	property map<TokenType, TokenPattern>? _patterns = null

	[public]
	[static]
	property map<TokenType, TokenPattern> patterns{
		get{
			if(_patterns == null){
				_patterns = map<TokenType, TokenPattern>{
					TokenType.CommentSingleline => new RegexTokenPattern("^//[^\n\r]*"),
					TokenType.Double => new RegexTokenPattern("^-?[0-9]+((\\.[0-9]+d)|d)"),
					TokenType.Float => new RegexTokenPattern("^-?[0-9]+((\\.[0-9]+(f?))|f)"),
					TokenType.Byte => new RegexTokenPattern("^-?[0-9]+b"),
					TokenType.Long => new RegexTokenPattern("^-?[0-9]+l"),
					TokenType.Integer => new RegexTokenPattern("^-?[0-9]+"),
					TokenType.ParenthesisOpen => new RegularTokenPattern("("),
					TokenType.ParenthesisClose => new RegularTokenPattern(")"),
					TokenType.BracketOpen => new RegularTokenPattern("["),
					TokenType.BracketClose => new RegularTokenPattern("]"),
					TokenType.BraceOpen => new RegularTokenPattern("{"),
					TokenType.BraceClose => new RegularTokenPattern("}"),
					TokenType.Comma => new RegularTokenPattern(","),
					TokenType.Dot => new RegularTokenPattern("."),
					TokenType.Colon => new RegularTokenPattern(":"),
					TokenType.Assign => new RegularTokenPattern("=>"),
					TokenType.PlusEquals => new RegularTokenPattern("+="),
					TokenType.PlusPlus => new RegularTokenPattern("++"),
					TokenType.Plus => new RegularTokenPattern("+"),
					TokenType.MinusEquals => new RegularTokenPattern("-="),
					TokenType.MinusMinus => new RegularTokenPattern("--"),
					TokenType.Minus => new RegularTokenPattern("-"),
					TokenType.MultiplyEquals => new RegularTokenPattern("*="),
					TokenType.Asterisk => new RegularTokenPattern("*"),
					TokenType.DivideEquals => new RegularTokenPattern("/="),
					TokenType.Slash => new RegularTokenPattern("/"),
					TokenType.ModuloEquals => new RegularTokenPattern("%="),
					TokenType.Modulo => new RegularTokenPattern("%"),
					TokenType.CheckEquals => new RegularTokenPattern("=="),
					TokenType.CheckNotEquals => new RegularTokenPattern("!="),
					TokenType.Equals => new RegularTokenPattern("="),
					TokenType.And => new RegularTokenPattern("&&"),
					TokenType.Ampersand => new RegularTokenPattern("&"),
					TokenType.Or => new RegularTokenPattern("||"),
					TokenType.Xor => new RegularTokenPattern("^"),
					TokenType.Negate => new RegularTokenPattern("!"),
					TokenType.LessThanOrEqual => new RegularTokenPattern("<="),
					TokenType.LessThan => new RegularTokenPattern("<"),
					TokenType.GreaterThanOrEqual => new RegularTokenPattern(">="),
					TokenType.GreaterThan => new RegularTokenPattern(">"),
					TokenType.Pipe => new RegularTokenPattern("|"),
					TokenType.Dollar => new RegularTokenPattern("$"),
					TokenType.QuestionAndExclamationMark => new RegularTokenPattern("?!"),
					TokenType.QuestionMark => new RegularTokenPattern("?"),
					TokenType.Identifier => new RegexTokenPattern("^[\\w_]+")
				}
			}
			return _patterns?!
		}
	}

	[readpublic]
	property TokenType type
	[readpublic]
	property string value
	[readpublic]
	property Location location
	[public]
	property list<Token>? comments
	
	method construct(TokenType type, string value, Location location){
		this.type = type
		this.value = value
		this.location = location
	}

}