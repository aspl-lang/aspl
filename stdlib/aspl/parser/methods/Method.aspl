import aspl.parser
import aspl.parser.classes
import aspl.parser.utils
import aspl.parser.ast.literals
import aspl.parser.attributes

[public]
[abstract]
class Method {

    [public]
    [static]
    [threadlocal]
    property map<string, map<string, Method>> methods = {}
    
    [readpublic]
    property Type type
    [readpublic]
    property string name
    [public]
    property list<Parameter> parameters
    [public]
    property int minimumParameterCount{
        get{
            var count = 0
            foreach(parameters as parameter){
                if(parameter.optional){
                    return count
                }
                count++
            }
            return count
        }
    }
    [public]
    property Types returnTypes
    [readpublic]
    property list<AttributeInstance> attributes
    [readpublic]
    property bool isAbstract = false
    [readpublic]
    property bool isStatic = false
    [readpublic]
    property bool isPublic = false
    [readpublic]
    property bool canThrow = false
    [readpublic]
    property bool fullyInitialized = true
    [readpublic]
    property bool createdFromAny = false

    [public]
    method construct(Type type, string name, list<Parameter> parameters, Types returnTypes, list<AttributeInstance> attributes) {
        this.type = type
        this.name = name
        this.parameters = parameters
        this.returnTypes = returnTypes
        this.attributes = attributes
    }

    [public]
    [static]
    method init(){
        new InternalMethod(Type:fromString("any"), "cloneShallow", [], new Types([]), []).register(null) // This is a special method and it's return types are generated by the compiler
        new InternalMethod(Type:fromString("any"), "cloneDeep", [], new Types([]), []).register(null) // This is a special method and it's return types are generated by the compiler

        new InternalMethod(Type:fromString("string"), "toLower", [], new Types([Type:fromString("string")]), []).register(null)
        new InternalMethod(Type:fromString("string"), "toUpper", [], new Types([Type:fromString("string")]), []).register(null)
        new InternalMethod(Type:fromString("string"), "replace", [new Parameter("search", new Types([Type:fromString("string")])), new Parameter("replace", new Types([Type:fromString("string")]))], new Types([Type:fromString("string")]), []).register(null)
        new InternalMethod(Type:fromString("string"), "replaceMany", [new Parameter("dictionary", new Types([Type:fromString("map<string, string>")]))], new Types([Type:fromString("string")]), []).register(null)
        new InternalMethod(Type:fromString("string"), "startsWith", [new Parameter("substring", new Types([Type:fromString("string")]))], new Types([Type:fromString("boolean")]), []).register(null)
        new InternalMethod(Type:fromString("string"), "endsWith", [new Parameter("substring", new Types([Type:fromString("string")]))], new Types([Type:fromString("boolean")]), []).register(null)
        new InternalMethod(Type:fromString("string"), "contains", [new Parameter("substring", new Types([Type:fromString("string")]))], new Types([Type:fromString("boolean")]), []).register(null)
        new InternalMethod(Type:fromString("string"), "after", [new Parameter("position", new Types([Type:fromString("integer")]))], new Types([Type:fromString("string")]), []).register(null)
        new InternalMethod(Type:fromString("string"), "before", [new Parameter("position", new Types([Type:fromString("integer")]))], new Types([Type:fromString("string")]), []).register(null)
        new InternalMethod(Type:fromString("string"), "trim", [new Parameter("chars", new Types([Type:fromString("string")]), new StringLiteral(" \n\t\v\f\r", " \\n\\t\\v\\f\\r", null))], new Types([Type:fromString("string")]), []).register(null)
        new InternalMethod(Type:fromString("string"), "trimStart", [], new Types([Type:fromString("string")]), []).register(null)
        new InternalMethod(Type:fromString("string"), "trimEnd", [], new Types([Type:fromString("string")]), []).register(null)
        new InternalMethod(Type:fromString("string"), "split", [new Parameter("delimiter", new Types([Type:fromString("string")])), new Parameter("maxParts", new Types([Type:fromString("integer")]), new IntegerLiteral(-1, null))], new Types([Type:fromString("list<string>")]), []).register(null)
        new InternalMethod(Type:fromString("string"), "reverse", [], new Types([Type:fromString("string")]), []).register(null)

        new InternalMethod(Type:fromString("list"), "contains", [new Parameter("element", new Types([Type:fromString("T")]))], new Types([Type:fromString("boolean")]), []).register(null)
        new InternalMethod(Type:fromString("list"), "add", [new Parameter("element", new Types([Type:fromString("T")]))], new Types([Type:fromString("list<T>")]), []).register(null)
        new InternalMethod(Type:fromString("list"), "insert", [new Parameter("index", new Types([Type:fromString("integer")])), new Parameter("element", new Types([Type:fromString("T")]))], new Types([Type:fromString("list<T>")]), []).register(null)
        new InternalMethod(Type:fromString("list"), "insertElements", [new Parameter("index", new Types([Type:fromString("integer")])), new Parameter("elements", new Types([Type:fromString("list<T>")]))], new Types([Type:fromString("list<T>")]), []).register(null)
        new InternalMethod(Type:fromString("list"), "remove", [new Parameter("element", new Types([Type:fromString("T")]))], new Types([Type:fromString("list<T>")]), []).register(null)
        new InternalMethod(Type:fromString("list"), "removeAt", [new Parameter("index", new Types([Type:fromString("integer")]))], new Types([Type:fromString("list<T>")]), []).register(null)
        new InternalMethod(Type:fromString("list"), "clear", [], new Types([Type:fromString("list<T>")]), []).register(null)
        new InternalMethod(Type:fromString("list"), "join", [new Parameter("delimiter", new Types([Type:fromString("string")]))], new Types([Type:fromString("string")]), []).register(null)

        new InternalMethod(Type:fromString("map"), "containsKey", [new Parameter("key", new Types([Type:fromString("T")]))], new Types([Type:fromString("boolean")]), []).register(null)
        new InternalMethod(Type:fromString("map"), "remove", [new Parameter("key", new Types([Type:fromString("T")]))], new Types([Type:fromString("map<T, U>")]), []).register(null)
        new InternalMethod(Type:fromString("map"), "clear", [], new Types([Type:fromString("map<T, U>")]), []).register(null)

        new InternalMethod(Type:fromString("callback"), "invoke", [], new Types([]), []).register(null) // This is a special method and it's parameters and return types are generated by the compiler
    }

    [public]
    method register(Location? location){
        if(self:methods.containsKey(this.type.toString())){
            if(self:methods[this.type.toString()].containsKey(name)){
                if(self:methods[this.type.toString()][name].fullyInitialized){
                    aspl.parser.utils.generic_error("Method '" + this.type.toString() + "." + this.name + "' already defined somewhere else", location)
                }
            }
        }
        if(!self:methods.containsKey(this.type.toString())){
            self:methods[this.type.toString()] = {}
        }
        self:methods[this.type.toString()][this.name] = this
    }

    [public]
    [static]
    method exists(Type type, string name, bool checkParents = true) returns bool{
        if(self:methods.containsKey(type.toString())){
            if(self:methods[type.toString()].containsKey(name)){
                return true
            }
        }
        if(checkParents && Class:classes.containsKey(type.toString())){
            foreach(Class:classes[type.toString()].parents as parent){
                if(self:exists(parent, name)){
                    return true
                }
            }
        }
        if(self:methods.containsKey("any")){
            if(self:methods["any"].containsKey(name)){
                return true
            }
        }
        return false
    }

    [public]
    [static]
    method get(Type type, string name) returns Method{
        if(self:methods.containsKey(type.toString())){
            if(self:methods[type.toString()].containsKey(name)){
                return self:methods[type.toString()][name]
            }
        }
        if(Class:classes.containsKey(type.toString())){
            foreach(Class:classes[type.toString()].parents as parent){
                if(self:exists(parent, name)){
                    return self:get(parent, name)
                }
            }
        }
        if(self:methods.containsKey("any")){
            if(self:methods["any"].containsKey(name)){
                return self:createMethodFromAny(type, name)
            }
        }
        aspl.parser.utils.fatal_error("Method '" + type.toString() + "." + name + "' not found (compiler bug)")
    }

    [public]
    [static]
    method getAllFor(Type type) returns list<Method>{
        var map<string, Method> methods = map<string, Method>{}
        if(self:methods.containsKey(type.toString())){
            foreach(self:methods[type.toString()] as m){
                methods[m.name] = m
            }
        }
        if(Class:classes.containsKey(type.toString())){
            foreach(Class:classes[type.toString()].parents as parent){
                foreach(self:getAllFor(parent) as m){
                    if(!methods.containsKey(m.name)){
                        methods[m.name] = m
                    }
                }
            }
        }
        if(self:methods.containsKey("any")){
            foreach(self:methods["any"] as m){
                if(!methods.containsKey(m.name)){
                    methods[m.name] = self:createMethodFromAny(type, m.name)
                }
            }
        }
        var list<Method> methodList = list<Method>[]
        foreach(methods as m){
            methodList.add(m)
        }
        return methodList
    }

    [public]
    [abstract]
    method withType(Type type) returns Method

    method setCreatedFromAny(bool createdFromAny = true){
        this.createdFromAny = createdFromAny
    }

    [public]
    [static]
    method createMethodFromAny(Type type, string name) returns Method{
        var newMethod = self:methods["any"][name].withType(type)
        newMethod.setCreatedFromAny()
        if(!self:methods.containsKey(type.toString())){
            self:methods[type.toString()] = {}
        }
        self:methods[type.toString()][name] = newMethod

        var list<Parameter> parameters = []        
        foreach(newMethod.parameters as parameter){
            var list<Type> paramTypes = []
            foreach(parameter.types.types as t){
                if(t.toString() == "T"){
                    paramTypes.add(type)
                }else{
                    paramTypes.add(t)
                }
            }
            parameters.add(new Parameter(parameter.name, new Types(paramTypes), parameter.defaultValue))
        }
        newMethod.parameters = parameters
        newMethod.register(null)

        var list<Type> returnTypes = []
        if(name == "cloneShallow" || name == "cloneDeep"){
            returnTypes.add(type)
        }else{
            foreach(newMethod.returnTypes.types as t){
                if(t.toString() == "T"){
                    returnTypes.add(type)
                }else{
                    returnTypes.add(t)
                }
            }
        }
        newMethod.returnTypes = new Types(returnTypes)

        return newMethod
    }
    
}